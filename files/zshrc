# .zshenv is always sourced, while .zshrc is only sourced in interactive shells

export TERM="xterm-256color"

# Put private interactive shell definitions in ~/.zshrc.local
# so they are ignored by Git and not inadvertently made public
if [[ -a ~/.zshrc.local ]]; then
  source ~/.zshrc.local
fi

# Gather all config files in dictionary-like array
typeset -U config_files # keep only one occurrence of each value
config_files=($HOME/.zsh/***/*.zsh) # *** recurses, follows symlinks

# Load the Oh-My-Zsh plugin files
for file in ${(M)config_files:#*/plugins*}; do
  source $file
done

# Load all but env, completion and plugin files
for file in ${${${config_files:#*/env*}:#*/completion*}:#*/plugins*}; do
  source $file
done

# Initialize autocomplete here so functions will load
autoload -U compinit
compinit

# Load every completion after autocomplete loads
for file in ${(M)config_files:#*/completion*}; do
  source $file
done

unset config_files
export PATH=$HOME/.local/bin:$PATH

# could also use systemd service, see
# https://wiki.archlinux.org/index.php/SSH_keys#Keychain
if ! pgrep -u "$USER" ssh-agent > /dev/null; then
  ssh-agent > ~/.ssh-agent-thing
fi
if [[ "$SSH_AGENT_PID" == "" ]]; then
  eval "$(<~/.ssh-agent-thing)" 1> /dev/null
fi

# ZSH_TMUX_AUTOSTART='true'
# TMUX
if which tmux >/dev/null 2>&1; then
  # if no session is started, start a new session
  test -z ${TMUX} && tmux

  # when quitting tmux, try to attach
  while test -z ${TMUX}; do
    tmux attach || break
  done
fi
